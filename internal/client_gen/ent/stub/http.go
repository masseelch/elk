// Package stub provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/masseelch/elk version (devel) DO NOT EDIT.
package stub

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// CategoryView defines model for CategoryView.
type CategoryView struct {
	Id   int64  `json:"id"`
	Name string `json:"name"`
}

// CollarView defines model for CollarView.
type CollarView struct {
	Color string `json:"color"`
	Id    int32  `json:"id"`
}

// OwnerView defines model for OwnerView.
type OwnerView struct {
	Age  int32  `json:"age"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// OwnerWithPetAndPetOwnerView defines model for OwnerWithPetAndPetOwnerView.
type OwnerWithPetAndPetOwnerView struct {
	Age  int32  `json:"age"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// PetView defines model for PetView.
type PetView struct {
	Age  int32  `json:"age"`
	Id   string `json:"id"`
	Name string `json:"name"`
}

// PetWithOwnerAndPetOwnerView defines model for PetWithOwnerAndPetOwnerView.
type PetWithOwnerAndPetOwnerView struct {
	Age     int32                          `json:"age"`
	Friends *[]PetWithOwnerAndPetOwnerView `json:"friends,omitempty"`
	Id      string                         `json:"id"`
	Name    string                         `json:"name"`
	Owner   *OwnerWithPetAndPetOwnerView   `json:"owner,omitempty"`
}

// N400 defines model for 400.
type N400 struct {
	Code   *int32                  `json:"code,omitempty"`
	Errors *map[string]interface{} `json:"errors,omitempty"`
	Status *string                 `json:"status,omitempty"`
}

// N404 defines model for 404.
type N404 struct {
	Code   *int32                  `json:"code,omitempty"`
	Errors *map[string]interface{} `json:"errors,omitempty"`
	Status *string                 `json:"status,omitempty"`
}

// N500 defines model for 500.
type N500 struct {
	Code   *int32                  `json:"code,omitempty"`
	Errors *map[string]interface{} `json:"errors,omitempty"`
	Status *string                 `json:"status,omitempty"`
}

// ListCategoryParams defines parameters for ListCategory.
type ListCategoryParams struct {
	// what page to render
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// CreateCategoryJSONBody defines parameters for CreateCategory.
type CreateCategoryJSONBody struct {
	Name string    `json:"name"`
	Pets *[]string `json:"pets,omitempty"`
}

// UpdateCategoryJSONBody defines parameters for UpdateCategory.
type UpdateCategoryJSONBody struct {
	Name string    `json:"name"`
	Pets *[]string `json:"pets,omitempty"`
}

// ListCategoryPetsParams defines parameters for ListCategoryPets.
type ListCategoryPetsParams struct {
	// ID of the Category
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// ListCollarParams defines parameters for ListCollar.
type ListCollarParams struct {
	// what page to render
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// CreateCollarJSONBody defines parameters for CreateCollar.
type CreateCollarJSONBody struct {
	Color string  `json:"color"`
	Pet   *string `json:"pet,omitempty"`
}

// UpdateCollarJSONBody defines parameters for UpdateCollar.
type UpdateCollarJSONBody struct {
	Color string  `json:"color"`
	Pet   *string `json:"pet,omitempty"`
}

// ListOwnerParams defines parameters for ListOwner.
type ListOwnerParams struct {
	// what page to render
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// CreateOwnerJSONBody defines parameters for CreateOwner.
type CreateOwnerJSONBody struct {
	Age  int32     `json:"age"`
	Name string    `json:"name"`
	Pets *[]string `json:"pets,omitempty"`
}

// UpdateOwnerJSONBody defines parameters for UpdateOwner.
type UpdateOwnerJSONBody struct {
	Age  int32     `json:"age"`
	Name string    `json:"name"`
	Pets *[]string `json:"pets,omitempty"`
}

// ListOwnerPetsParams defines parameters for ListOwnerPets.
type ListOwnerPetsParams struct {
	// ID of the Owner
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// ListPetParams defines parameters for ListPet.
type ListPetParams struct {
	// what page to render
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// CreatePetJSONBody defines parameters for CreatePet.
type CreatePetJSONBody struct {
	Age        int32     `json:"age"`
	Categories *[]int64  `json:"categories,omitempty"`
	Collar     *int32    `json:"collar,omitempty"`
	Friends    *[]string `json:"friends,omitempty"`
	Name       string    `json:"name"`
	Owner      *string   `json:"owner,omitempty"`
}

// UpdatePetJSONBody defines parameters for UpdatePet.
type UpdatePetJSONBody struct {
	Age        int32     `json:"age"`
	Categories *[]int64  `json:"categories,omitempty"`
	Collar     *int32    `json:"collar,omitempty"`
	Friends    *[]string `json:"friends,omitempty"`
	Name       string    `json:"name"`
	Owner      *string   `json:"owner,omitempty"`
}

// ListPetCategoriesParams defines parameters for ListPetCategories.
type ListPetCategoriesParams struct {
	// ID of the Pet
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// ListPetFriendsParams defines parameters for ListPetFriends.
type ListPetFriendsParams struct {
	// ID of the Pet
	Page *int32 `json:"page,omitempty"`

	// item count to render per page
	ItemsPerPage *int32 `json:"itemsPerPage,omitempty"`
}

// CreateCategoryJSONRequestBody defines body for CreateCategory for application/json ContentType.
type CreateCategoryJSONRequestBody = CreateCategoryJSONBody

// UpdateCategoryJSONRequestBody defines body for UpdateCategory for application/json ContentType.
type UpdateCategoryJSONRequestBody = UpdateCategoryJSONBody

// CreateCollarJSONRequestBody defines body for CreateCollar for application/json ContentType.
type CreateCollarJSONRequestBody = CreateCollarJSONBody

// UpdateCollarJSONRequestBody defines body for UpdateCollar for application/json ContentType.
type UpdateCollarJSONRequestBody = UpdateCollarJSONBody

// CreateOwnerJSONRequestBody defines body for CreateOwner for application/json ContentType.
type CreateOwnerJSONRequestBody = CreateOwnerJSONBody

// UpdateOwnerJSONRequestBody defines body for UpdateOwner for application/json ContentType.
type UpdateOwnerJSONRequestBody = UpdateOwnerJSONBody

// CreatePetJSONRequestBody defines body for CreatePet for application/json ContentType.
type CreatePetJSONRequestBody = CreatePetJSONBody

// UpdatePetJSONRequestBody defines body for UpdatePet for application/json ContentType.
type UpdatePetJSONRequestBody = UpdatePetJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListCategory request
	ListCategory(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCategory request with any body
	CreateCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCategory(ctx context.Context, body CreateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCategory request
	DeleteCategory(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadCategory request
	ReadCategory(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCategory request with any body
	UpdateCategoryWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCategory(ctx context.Context, id int64, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCategoryPets request
	ListCategoryPets(ctx context.Context, id int64, params *ListCategoryPetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollar request
	ListCollar(ctx context.Context, params *ListCollarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCollar request with any body
	CreateCollarWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCollar(ctx context.Context, body CreateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollar request
	DeleteCollar(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadCollar request
	ReadCollar(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCollar request with any body
	UpdateCollarWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCollar(ctx context.Context, id int32, body UpdateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadCollarPet request
	ReadCollarPet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOwner request
	ListOwner(ctx context.Context, params *ListOwnerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOwner request with any body
	CreateOwnerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOwner(ctx context.Context, body CreateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOwner request
	DeleteOwner(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadOwner request
	ReadOwner(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOwner request with any body
	UpdateOwnerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOwner(ctx context.Context, id string, body UpdateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOwnerPets request
	ListOwnerPets(ctx context.Context, id string, params *ListOwnerPetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPet request
	ListPet(ctx context.Context, params *ListPetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePet request with any body
	CreatePetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePet(ctx context.Context, body CreatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePet request
	DeletePet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPet request
	ReadPet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePet request with any body
	UpdatePetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePet(ctx context.Context, id string, body UpdatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPetCategories request
	ListPetCategories(ctx context.Context, id string, params *ListPetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPetCollar request
	ReadPetCollar(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPetFriends request
	ListPetFriends(ctx context.Context, id string, params *ListPetFriendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPetOwner request
	ReadPetOwner(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListCategory(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCategory(ctx context.Context, body CreateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCategory(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCategoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadCategory(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadCategoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCategoryWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCategoryRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCategory(ctx context.Context, id int64, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCategoryRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCategoryPets(ctx context.Context, id int64, params *ListCategoryPetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCategoryPetsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollar(ctx context.Context, params *ListCollarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollarRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollarWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollarRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollar(ctx context.Context, body CreateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollarRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollar(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollarRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadCollar(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadCollarRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollarWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollarRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollar(ctx context.Context, id int32, body UpdateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollarRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadCollarPet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadCollarPetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOwner(ctx context.Context, params *ListOwnerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOwnerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOwnerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOwnerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOwner(ctx context.Context, body CreateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOwnerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOwner(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOwnerRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadOwner(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadOwnerRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOwnerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOwnerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOwner(ctx context.Context, id string, body UpdateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOwnerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOwnerPets(ctx context.Context, id string, params *ListOwnerPetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOwnerPetsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPet(ctx context.Context, params *ListPetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePet(ctx context.Context, body CreatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePetRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePet(ctx context.Context, id string, body UpdatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePetRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPetCategories(ctx context.Context, id string, params *ListPetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPetCategoriesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPetCollar(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPetCollarRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPetFriends(ctx context.Context, id string, params *ListPetFriendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPetFriendsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPetOwner(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPetOwnerRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListCategoryRequest generates requests for ListCategory
func NewListCategoryRequest(server string, params *ListCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCategoryRequest calls the generic CreateCategory builder with application/json body
func NewCreateCategoryRequest(server string, body CreateCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCategoryRequestWithBody generates requests for CreateCategory with any type of body
func NewCreateCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCategoryRequest generates requests for DeleteCategory
func NewDeleteCategoryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadCategoryRequest generates requests for ReadCategory
func NewReadCategoryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCategoryRequest calls the generic UpdateCategory builder with application/json body
func NewUpdateCategoryRequest(server string, id int64, body UpdateCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCategoryRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCategoryRequestWithBody generates requests for UpdateCategory with any type of body
func NewUpdateCategoryRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCategoryPetsRequest generates requests for ListCategoryPets
func NewListCategoryPetsRequest(server string, id int64, params *ListCategoryPetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s/pets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCollarRequest generates requests for ListCollar
func NewListCollarRequest(server string, params *ListCollarParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collars")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCollarRequest calls the generic CreateCollar builder with application/json body
func NewCreateCollarRequest(server string, body CreateCollarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCollarRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCollarRequestWithBody generates requests for CreateCollar with any type of body
func NewCreateCollarRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collars")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollarRequest generates requests for DeleteCollar
func NewDeleteCollarRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collars/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadCollarRequest generates requests for ReadCollar
func NewReadCollarRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collars/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCollarRequest calls the generic UpdateCollar builder with application/json body
func NewUpdateCollarRequest(server string, id int32, body UpdateCollarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCollarRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCollarRequestWithBody generates requests for UpdateCollar with any type of body
func NewUpdateCollarRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collars/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadCollarPetRequest generates requests for ReadCollarPet
func NewReadCollarPetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collars/%s/pet", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOwnerRequest generates requests for ListOwner
func NewListOwnerRequest(server string, params *ListOwnerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/owners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOwnerRequest calls the generic CreateOwner builder with application/json body
func NewCreateOwnerRequest(server string, body CreateOwnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOwnerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOwnerRequestWithBody generates requests for CreateOwner with any type of body
func NewCreateOwnerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/owners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOwnerRequest generates requests for DeleteOwner
func NewDeleteOwnerRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/owners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadOwnerRequest generates requests for ReadOwner
func NewReadOwnerRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/owners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOwnerRequest calls the generic UpdateOwner builder with application/json body
func NewUpdateOwnerRequest(server string, id string, body UpdateOwnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOwnerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateOwnerRequestWithBody generates requests for UpdateOwner with any type of body
func NewUpdateOwnerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/owners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOwnerPetsRequest generates requests for ListOwnerPets
func NewListOwnerPetsRequest(server string, id string, params *ListOwnerPetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/owners/%s/pets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPetRequest generates requests for ListPet
func NewListPetRequest(server string, params *ListPetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePetRequest calls the generic CreatePet builder with application/json body
func NewCreatePetRequest(server string, body CreatePetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePetRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePetRequestWithBody generates requests for CreatePet with any type of body
func NewCreatePetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePetRequest generates requests for DeletePet
func NewDeletePetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPetRequest generates requests for ReadPet
func NewReadPetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePetRequest calls the generic UpdatePet builder with application/json body
func NewUpdatePetRequest(server string, id string, body UpdatePetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePetRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePetRequestWithBody generates requests for UpdatePet with any type of body
func NewUpdatePetRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPetCategoriesRequest generates requests for ListPetCategories
func NewListPetCategoriesRequest(server string, id string, params *ListPetCategoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets/%s/categories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPetCollarRequest generates requests for ReadPetCollar
func NewReadPetCollarRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets/%s/collar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPetFriendsRequest generates requests for ListPetFriends
func NewListPetFriendsRequest(server string, id string, params *ListPetFriendsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets/%s/friends", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ItemsPerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemsPerPage", runtime.ParamLocationQuery, *params.ItemsPerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPetOwnerRequest generates requests for ReadPetOwner
func NewReadPetOwnerRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pets/%s/owner", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListCategory request
	ListCategoryWithResponse(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*ListCategoryResponse, error)

	// CreateCategory request with any body
	CreateCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCategoryResponse, error)

	CreateCategoryWithResponse(ctx context.Context, body CreateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCategoryResponse, error)

	// DeleteCategory request
	DeleteCategoryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error)

	// ReadCategory request
	ReadCategoryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*ReadCategoryResponse, error)

	// UpdateCategory request with any body
	UpdateCategoryWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error)

	UpdateCategoryWithResponse(ctx context.Context, id int64, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error)

	// ListCategoryPets request
	ListCategoryPetsWithResponse(ctx context.Context, id int64, params *ListCategoryPetsParams, reqEditors ...RequestEditorFn) (*ListCategoryPetsResponse, error)

	// ListCollar request
	ListCollarWithResponse(ctx context.Context, params *ListCollarParams, reqEditors ...RequestEditorFn) (*ListCollarResponse, error)

	// CreateCollar request with any body
	CreateCollarWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollarResponse, error)

	CreateCollarWithResponse(ctx context.Context, body CreateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollarResponse, error)

	// DeleteCollar request
	DeleteCollarWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*DeleteCollarResponse, error)

	// ReadCollar request
	ReadCollarWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ReadCollarResponse, error)

	// UpdateCollar request with any body
	UpdateCollarWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollarResponse, error)

	UpdateCollarWithResponse(ctx context.Context, id int32, body UpdateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollarResponse, error)

	// ReadCollarPet request
	ReadCollarPetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadCollarPetResponse, error)

	// ListOwner request
	ListOwnerWithResponse(ctx context.Context, params *ListOwnerParams, reqEditors ...RequestEditorFn) (*ListOwnerResponse, error)

	// CreateOwner request with any body
	CreateOwnerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOwnerResponse, error)

	CreateOwnerWithResponse(ctx context.Context, body CreateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOwnerResponse, error)

	// DeleteOwner request
	DeleteOwnerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOwnerResponse, error)

	// ReadOwner request
	ReadOwnerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadOwnerResponse, error)

	// UpdateOwner request with any body
	UpdateOwnerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOwnerResponse, error)

	UpdateOwnerWithResponse(ctx context.Context, id string, body UpdateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOwnerResponse, error)

	// ListOwnerPets request
	ListOwnerPetsWithResponse(ctx context.Context, id string, params *ListOwnerPetsParams, reqEditors ...RequestEditorFn) (*ListOwnerPetsResponse, error)

	// ListPet request
	ListPetWithResponse(ctx context.Context, params *ListPetParams, reqEditors ...RequestEditorFn) (*ListPetResponse, error)

	// CreatePet request with any body
	CreatePetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePetResponse, error)

	CreatePetWithResponse(ctx context.Context, body CreatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePetResponse, error)

	// DeletePet request
	DeletePetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePetResponse, error)

	// ReadPet request
	ReadPetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPetResponse, error)

	// UpdatePet request with any body
	UpdatePetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePetResponse, error)

	UpdatePetWithResponse(ctx context.Context, id string, body UpdatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePetResponse, error)

	// ListPetCategories request
	ListPetCategoriesWithResponse(ctx context.Context, id string, params *ListPetCategoriesParams, reqEditors ...RequestEditorFn) (*ListPetCategoriesResponse, error)

	// ReadPetCollar request
	ReadPetCollarWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ReadPetCollarResponse, error)

	// ListPetFriends request
	ListPetFriendsWithResponse(ctx context.Context, id string, params *ListPetFriendsParams, reqEditors ...RequestEditorFn) (*ListPetFriendsResponse, error)

	// ReadPetOwner request
	ReadPetOwnerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPetOwnerResponse, error)
}

type ListCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CategoryView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoryView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoryView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoryView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCategoryPetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PetView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCategoryPetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCategoryPetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CollarView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCollarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCollarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollarView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateCollarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteCollarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadCollarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollarView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadCollarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadCollarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCollarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollarView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateCollarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCollarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadCollarPetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PetWithOwnerAndPetOwnerView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadCollarPetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadCollarPetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OwnerView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OwnerView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OwnerView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OwnerView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOwnerPetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PetView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOwnerPetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOwnerPetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PetView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PetView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PetWithOwnerAndPetOwnerView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadPetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PetView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPetCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CategoryView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPetCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPetCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPetCollarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollarView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadPetCollarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPetCollarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPetFriendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PetView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPetFriendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPetFriendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPetOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OwnerView
	JSON400      *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON404 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
	JSON500 *struct {
		Code   *int32                  `json:"code,omitempty"`
		Errors *map[string]interface{} `json:"errors,omitempty"`
		Status *string                 `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadPetOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPetOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListCategoryWithResponse request returning *ListCategoryResponse
func (c *ClientWithResponses) ListCategoryWithResponse(ctx context.Context, params *ListCategoryParams, reqEditors ...RequestEditorFn) (*ListCategoryResponse, error) {
	rsp, err := c.ListCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCategoryResponse(rsp)
}

// CreateCategoryWithBodyWithResponse request with arbitrary body returning *CreateCategoryResponse
func (c *ClientWithResponses) CreateCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCategoryResponse, error) {
	rsp, err := c.CreateCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCategoryResponse(rsp)
}

func (c *ClientWithResponses) CreateCategoryWithResponse(ctx context.Context, body CreateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCategoryResponse, error) {
	rsp, err := c.CreateCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCategoryResponse(rsp)
}

// DeleteCategoryWithResponse request returning *DeleteCategoryResponse
func (c *ClientWithResponses) DeleteCategoryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DeleteCategoryResponse, error) {
	rsp, err := c.DeleteCategory(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCategoryResponse(rsp)
}

// ReadCategoryWithResponse request returning *ReadCategoryResponse
func (c *ClientWithResponses) ReadCategoryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*ReadCategoryResponse, error) {
	rsp, err := c.ReadCategory(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadCategoryResponse(rsp)
}

// UpdateCategoryWithBodyWithResponse request with arbitrary body returning *UpdateCategoryResponse
func (c *ClientWithResponses) UpdateCategoryWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error) {
	rsp, err := c.UpdateCategoryWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCategoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateCategoryWithResponse(ctx context.Context, id int64, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error) {
	rsp, err := c.UpdateCategory(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCategoryResponse(rsp)
}

// ListCategoryPetsWithResponse request returning *ListCategoryPetsResponse
func (c *ClientWithResponses) ListCategoryPetsWithResponse(ctx context.Context, id int64, params *ListCategoryPetsParams, reqEditors ...RequestEditorFn) (*ListCategoryPetsResponse, error) {
	rsp, err := c.ListCategoryPets(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCategoryPetsResponse(rsp)
}

// ListCollarWithResponse request returning *ListCollarResponse
func (c *ClientWithResponses) ListCollarWithResponse(ctx context.Context, params *ListCollarParams, reqEditors ...RequestEditorFn) (*ListCollarResponse, error) {
	rsp, err := c.ListCollar(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollarResponse(rsp)
}

// CreateCollarWithBodyWithResponse request with arbitrary body returning *CreateCollarResponse
func (c *ClientWithResponses) CreateCollarWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollarResponse, error) {
	rsp, err := c.CreateCollarWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollarResponse(rsp)
}

func (c *ClientWithResponses) CreateCollarWithResponse(ctx context.Context, body CreateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollarResponse, error) {
	rsp, err := c.CreateCollar(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollarResponse(rsp)
}

// DeleteCollarWithResponse request returning *DeleteCollarResponse
func (c *ClientWithResponses) DeleteCollarWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*DeleteCollarResponse, error) {
	rsp, err := c.DeleteCollar(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollarResponse(rsp)
}

// ReadCollarWithResponse request returning *ReadCollarResponse
func (c *ClientWithResponses) ReadCollarWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ReadCollarResponse, error) {
	rsp, err := c.ReadCollar(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadCollarResponse(rsp)
}

// UpdateCollarWithBodyWithResponse request with arbitrary body returning *UpdateCollarResponse
func (c *ClientWithResponses) UpdateCollarWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollarResponse, error) {
	rsp, err := c.UpdateCollarWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollarResponse(rsp)
}

func (c *ClientWithResponses) UpdateCollarWithResponse(ctx context.Context, id int32, body UpdateCollarJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollarResponse, error) {
	rsp, err := c.UpdateCollar(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollarResponse(rsp)
}

// ReadCollarPetWithResponse request returning *ReadCollarPetResponse
func (c *ClientWithResponses) ReadCollarPetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadCollarPetResponse, error) {
	rsp, err := c.ReadCollarPet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadCollarPetResponse(rsp)
}

// ListOwnerWithResponse request returning *ListOwnerResponse
func (c *ClientWithResponses) ListOwnerWithResponse(ctx context.Context, params *ListOwnerParams, reqEditors ...RequestEditorFn) (*ListOwnerResponse, error) {
	rsp, err := c.ListOwner(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOwnerResponse(rsp)
}

// CreateOwnerWithBodyWithResponse request with arbitrary body returning *CreateOwnerResponse
func (c *ClientWithResponses) CreateOwnerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOwnerResponse, error) {
	rsp, err := c.CreateOwnerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOwnerResponse(rsp)
}

func (c *ClientWithResponses) CreateOwnerWithResponse(ctx context.Context, body CreateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOwnerResponse, error) {
	rsp, err := c.CreateOwner(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOwnerResponse(rsp)
}

// DeleteOwnerWithResponse request returning *DeleteOwnerResponse
func (c *ClientWithResponses) DeleteOwnerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOwnerResponse, error) {
	rsp, err := c.DeleteOwner(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOwnerResponse(rsp)
}

// ReadOwnerWithResponse request returning *ReadOwnerResponse
func (c *ClientWithResponses) ReadOwnerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadOwnerResponse, error) {
	rsp, err := c.ReadOwner(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadOwnerResponse(rsp)
}

// UpdateOwnerWithBodyWithResponse request with arbitrary body returning *UpdateOwnerResponse
func (c *ClientWithResponses) UpdateOwnerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOwnerResponse, error) {
	rsp, err := c.UpdateOwnerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOwnerResponse(rsp)
}

func (c *ClientWithResponses) UpdateOwnerWithResponse(ctx context.Context, id string, body UpdateOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOwnerResponse, error) {
	rsp, err := c.UpdateOwner(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOwnerResponse(rsp)
}

// ListOwnerPetsWithResponse request returning *ListOwnerPetsResponse
func (c *ClientWithResponses) ListOwnerPetsWithResponse(ctx context.Context, id string, params *ListOwnerPetsParams, reqEditors ...RequestEditorFn) (*ListOwnerPetsResponse, error) {
	rsp, err := c.ListOwnerPets(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOwnerPetsResponse(rsp)
}

// ListPetWithResponse request returning *ListPetResponse
func (c *ClientWithResponses) ListPetWithResponse(ctx context.Context, params *ListPetParams, reqEditors ...RequestEditorFn) (*ListPetResponse, error) {
	rsp, err := c.ListPet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPetResponse(rsp)
}

// CreatePetWithBodyWithResponse request with arbitrary body returning *CreatePetResponse
func (c *ClientWithResponses) CreatePetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePetResponse, error) {
	rsp, err := c.CreatePetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePetResponse(rsp)
}

func (c *ClientWithResponses) CreatePetWithResponse(ctx context.Context, body CreatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePetResponse, error) {
	rsp, err := c.CreatePet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePetResponse(rsp)
}

// DeletePetWithResponse request returning *DeletePetResponse
func (c *ClientWithResponses) DeletePetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePetResponse, error) {
	rsp, err := c.DeletePet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePetResponse(rsp)
}

// ReadPetWithResponse request returning *ReadPetResponse
func (c *ClientWithResponses) ReadPetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPetResponse, error) {
	rsp, err := c.ReadPet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPetResponse(rsp)
}

// UpdatePetWithBodyWithResponse request with arbitrary body returning *UpdatePetResponse
func (c *ClientWithResponses) UpdatePetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePetResponse, error) {
	rsp, err := c.UpdatePetWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePetResponse(rsp)
}

func (c *ClientWithResponses) UpdatePetWithResponse(ctx context.Context, id string, body UpdatePetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePetResponse, error) {
	rsp, err := c.UpdatePet(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePetResponse(rsp)
}

// ListPetCategoriesWithResponse request returning *ListPetCategoriesResponse
func (c *ClientWithResponses) ListPetCategoriesWithResponse(ctx context.Context, id string, params *ListPetCategoriesParams, reqEditors ...RequestEditorFn) (*ListPetCategoriesResponse, error) {
	rsp, err := c.ListPetCategories(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPetCategoriesResponse(rsp)
}

// ReadPetCollarWithResponse request returning *ReadPetCollarResponse
func (c *ClientWithResponses) ReadPetCollarWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ReadPetCollarResponse, error) {
	rsp, err := c.ReadPetCollar(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPetCollarResponse(rsp)
}

// ListPetFriendsWithResponse request returning *ListPetFriendsResponse
func (c *ClientWithResponses) ListPetFriendsWithResponse(ctx context.Context, id string, params *ListPetFriendsParams, reqEditors ...RequestEditorFn) (*ListPetFriendsResponse, error) {
	rsp, err := c.ListPetFriends(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPetFriendsResponse(rsp)
}

// ReadPetOwnerWithResponse request returning *ReadPetOwnerResponse
func (c *ClientWithResponses) ReadPetOwnerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPetOwnerResponse, error) {
	rsp, err := c.ReadPetOwner(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPetOwnerResponse(rsp)
}

// ParseListCategoryResponse parses an HTTP response from a ListCategoryWithResponse call
func ParseListCategoryResponse(rsp *http.Response) (*ListCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CategoryView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCategoryResponse parses an HTTP response from a CreateCategoryWithResponse call
func ParseCreateCategoryResponse(rsp *http.Response) (*CreateCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoryView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCategoryResponse parses an HTTP response from a DeleteCategoryWithResponse call
func ParseDeleteCategoryResponse(rsp *http.Response) (*DeleteCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadCategoryResponse parses an HTTP response from a ReadCategoryWithResponse call
func ParseReadCategoryResponse(rsp *http.Response) (*ReadCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReadCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoryView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCategoryResponse parses an HTTP response from a UpdateCategoryWithResponse call
func ParseUpdateCategoryResponse(rsp *http.Response) (*UpdateCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoryView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCategoryPetsResponse parses an HTTP response from a ListCategoryPetsWithResponse call
func ParseListCategoryPetsResponse(rsp *http.Response) (*ListCategoryPetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCategoryPetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PetView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCollarResponse parses an HTTP response from a ListCollarWithResponse call
func ParseListCollarResponse(rsp *http.Response) (*ListCollarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCollarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CollarView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCollarResponse parses an HTTP response from a CreateCollarWithResponse call
func ParseCreateCollarResponse(rsp *http.Response) (*CreateCollarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCollarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollarView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollarResponse parses an HTTP response from a DeleteCollarWithResponse call
func ParseDeleteCollarResponse(rsp *http.Response) (*DeleteCollarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadCollarResponse parses an HTTP response from a ReadCollarWithResponse call
func ParseReadCollarResponse(rsp *http.Response) (*ReadCollarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReadCollarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollarView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCollarResponse parses an HTTP response from a UpdateCollarWithResponse call
func ParseUpdateCollarResponse(rsp *http.Response) (*UpdateCollarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateCollarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollarView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadCollarPetResponse parses an HTTP response from a ReadCollarPetWithResponse call
func ParseReadCollarPetResponse(rsp *http.Response) (*ReadCollarPetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReadCollarPetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PetWithOwnerAndPetOwnerView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOwnerResponse parses an HTTP response from a ListOwnerWithResponse call
func ParseListOwnerResponse(rsp *http.Response) (*ListOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OwnerView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOwnerResponse parses an HTTP response from a CreateOwnerWithResponse call
func ParseCreateOwnerResponse(rsp *http.Response) (*CreateOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OwnerView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOwnerResponse parses an HTTP response from a DeleteOwnerWithResponse call
func ParseDeleteOwnerResponse(rsp *http.Response) (*DeleteOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadOwnerResponse parses an HTTP response from a ReadOwnerWithResponse call
func ParseReadOwnerResponse(rsp *http.Response) (*ReadOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReadOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OwnerView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOwnerResponse parses an HTTP response from a UpdateOwnerWithResponse call
func ParseUpdateOwnerResponse(rsp *http.Response) (*UpdateOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OwnerView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOwnerPetsResponse parses an HTTP response from a ListOwnerPetsWithResponse call
func ParseListOwnerPetsResponse(rsp *http.Response) (*ListOwnerPetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListOwnerPetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PetView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPetResponse parses an HTTP response from a ListPetWithResponse call
func ParseListPetResponse(rsp *http.Response) (*ListPetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PetView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePetResponse parses an HTTP response from a CreatePetWithResponse call
func ParseCreatePetResponse(rsp *http.Response) (*CreatePetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PetView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePetResponse parses an HTTP response from a DeletePetWithResponse call
func ParseDeletePetResponse(rsp *http.Response) (*DeletePetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadPetResponse parses an HTTP response from a ReadPetWithResponse call
func ParseReadPetResponse(rsp *http.Response) (*ReadPetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReadPetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PetWithOwnerAndPetOwnerView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePetResponse parses an HTTP response from a UpdatePetWithResponse call
func ParseUpdatePetResponse(rsp *http.Response) (*UpdatePetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PetView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPetCategoriesResponse parses an HTTP response from a ListPetCategoriesWithResponse call
func ParseListPetCategoriesResponse(rsp *http.Response) (*ListPetCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPetCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CategoryView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadPetCollarResponse parses an HTTP response from a ReadPetCollarWithResponse call
func ParseReadPetCollarResponse(rsp *http.Response) (*ReadPetCollarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReadPetCollarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollarView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPetFriendsResponse parses an HTTP response from a ListPetFriendsWithResponse call
func ParseListPetFriendsResponse(rsp *http.Response) (*ListPetFriendsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPetFriendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PetView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadPetOwnerResponse parses an HTTP response from a ReadPetOwnerWithResponse call
func ParseReadPetOwnerResponse(rsp *http.Response) (*ReadPetOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ReadPetOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OwnerView
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Code   *int32                  `json:"code,omitempty"`
			Errors *map[string]interface{} `json:"errors,omitempty"`
			Status *string                 `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
